% --- Simple Script to Analyze a Transfer Function (tf1) ---

% This script assumes that a continuous-time transfer function model named 'tf1'
% already exists in your MATLAB workspace.
% 'tf1' would typically be an 'idtf' object if estimated from the System ID app,
% or a 'tf' object if created manually or by other means.

% Check if tf1 exists in the workspace
if ~exist('tf1', 'var')
    disp('Error: Transfer function model ''tf1'' not found in the workspace.');
    disp('Please ensure ''tf1'' is loaded or created before running this script.');
    
    % As a placeholder/example, let's create a sample tf1 if it doesn't exist.
    % YOU SHOULD REPLACE THIS WITH YOUR ACTUAL tf1 if it's not being automatically
    % generated by a preceding script or imported from the System ID app.
    disp('Creating a sample tf1 for demonstration purposes...');
    % Example: A generic underdamped second-order system
    % G(s) = omega_n^2 / (s^2 + 2*zeta*omega_n*s + omega_n^2)
    zeta_sample = 0.5;       % Damping ratio
    omega_n_sample = 10;     % Natural frequency (rad/s)
    numerator_sample = omega_n_sample^2;
    denominator_sample = [1, 2*zeta_sample*omega_n_sample, omega_n_sample^2];
    tf1 = tf(numerator_sample, denominator_sample); % Create a 'tf' object
    disp('Sample tf1 created:');
    disp(tf1);
    disp('---');
end

% --- 1. Determine Natural Frequency (omega_n) and Damping Ratio (zeta) ---
% The `damp` function is ideal for this [2][3].
% It works for both 'tf' and 'idtf' model objects.

disp('--- System Characteristics (from damp function) ---');
try
    % `damp(sys)` displays information including wn and zeta.
    % `[wn_array, zeta_array, poles_array] = damp(sys)` returns the values.
    [wn_values, zeta_values, poles] = damp(tf1); 
    
    % For a typical 2nd order system, we expect one dominant wn and zeta
    % if the poles form a complex conjugate pair, or two real poles.
    % If multiple modes/poles, damp returns arrays. We'll focus on the
    % most relevant ones (often the lowest frequency, non-zero damping).
    
    % Display all found values (damp function itself also prints a table)
    % damp(tf1); % This line alone would print a formatted table [2].

    if isempty(wn_values)
        disp('No natural frequencies found (e.g., system might be first order or static gain).');
    else
        % For a 2-pole system, there might be one or two wn/zeta pairs
        % depending on whether the poles are real or complex conjugate.
        % We usually care about the values corresponding to oscillatory modes.
        for i = 1:length(wn_values)
            fprintf('Mode %d:\n', i);
            fprintf('  Natural Frequency (omega_n): %.4f rad/s\n', wn_values(i));
            fprintf('  Damping Ratio (zeta):        %.4f\n', zeta_values(i));
            fprintf('  Pole:                        %s\n', compl2str(poles(i)));
        end
        
        % If you specifically want THE natural frequency and damping ratio for a
        % dominant second-order behavior, you might select the one with the
        % lowest frequency or based on pole location. For tf1 estimated as
        % a 2-pole system, this should be straightforward.
        % Let's assume the first relevant entry is what we need if complex,
        % or handle real poles appropriately.
        
        % Heuristic: Pick the first wn/zeta pair from damp's output (it sorts by frequency)
        % This is generally appropriate for the dominant poles of a 2nd order system.
        natural_frequency = wn_values(1);
        damping_ratio = zeta_values(1);
        
        fprintf('\nSelected Dominant Mode Parameters:\n');
        fprintf('  Dominant Natural Frequency (omega_n): %.4f rad/s\n', natural_frequency);
        fprintf('  Dominant Damping Ratio (zeta):        %.4f\n', damping_ratio);
    end

catch ME
    disp('Error using damp function:');
    disp(ME.message);
    disp('Ensure ''tf1'' is a valid LTI model object (tf, ss, zpk, idtf, etc.).');
end
disp('----------------------------------------------------');

% --- 2. Determine Max Rate ---
% Determining "max rate" can be context-dependent and is not a direct property
% extracted like wn or zeta from the transfer function itself without more info.
% It usually refers to the maximum rate of change of the system's output (dy/dt)
% in response to a specific input, often a step input.

disp('--- Max Rate Estimation (for a unit step input) ---');
try
    % To estimate max rate, we typically simulate the step response.
    % Get the step response info
    [y_step, t_step] = step(tf1); % Simulates response to a unit step input

    if isempty(y_step) || length(y_step) < 2
        disp('Could not obtain a valid step response to calculate max rate.');
    else
        % Calculate the derivative of the output y_step with respect to time t_step
        dy_dt = diff(y_step) ./ diff(t_step);
        
        % The max rate is the maximum absolute value of this derivative
        max_rate = max(abs(dy_dt));
        
        fprintf('Estimated Max Rate of Output (dy/dt) for a UNIT step input: %.4f units/second\n', max_rate);
        fprintf('(Assuming output unit is ''mm'' and time in ''seconds'', this is mm/s for a unit step)\n');
        
        % If tf1 was identified with a step input of 4.2 mm:
        % The 'step' command simulates response to a UNIT step.
        % If your actual input step amplitude (e.g., 4.2 mm from previous context)
        % is known and tf1 is scaled to that, the output y_step from step(tf1)
        % would correspond to a unit step.
        % If tf1's gain inherently includes the 4.2mm step (i.e., input was 1, output includes the 4.2 factor),
        % then max_rate here is the actual max rate for that 4.2mm effective input.
        % If tf1 is normalized (e.g. input was 4.2, output is actuator pos, so gain is ~1),
        % then to get max rate for a 4.2mm step, you'd multiply by 4.2:
        % max_rate_for_4_2_mm_step = max_rate * 4.2; (If tf1 represents system with gain ~1 for that step)
        
        % From your image 'Screenshot-2025-05-20-at-17.09.26.jpg' [1],
        % the input was 'StepInput_mm'. If tf1 correctly models the system
        % such that a unit step input to tf1 corresponds to the system's response
        % to a 1mm step, then max_rate calculated above is per mm of input step.
        % For an actual 4.2mm step, the max rate would be:
        actual_step_amplitude = 4.2; % mm, from previous context
        max_rate_for_actual_step = max_rate * actual_step_amplitude;
        fprintf('Estimated Max Rate for a %.1f mm step input: %.4f mm/second\n', actual_step_amplitude, max_rate_for_actual_step);

    end
catch ME_step
    disp('Error calculating max rate from step response:');
    disp(ME_step.message);
end
disp('---------------------------------------------------');

% --- Helper function to display complex numbers nicely ---
function s = compl2str(c)
    if imag(c) == 0
        s = sprintf('%.4f', real(c));
    elseif real(c) == 0
        s = sprintf('%.4fi', imag(c));
    elseif imag(c) < 0
        s = sprintf('%.4f - %.4fi', real(c), abs(imag(c)));
    else
        s = sprintf('%.4f + %.4fi', real(c), imag(c));
    end
end

% --- End of Script ---
